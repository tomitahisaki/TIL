# 基礎理論
# 基数変換
## 進数
人が日常的に使うのは、**10進数**

**N進数の重み**
小数点を基準に右へ、Nの0乗、1乗、2乗の順になっていく

小数点を基準に左へ、Nの-1乗、−2乗の順になっていく


## N進数から10進数への基数変換
各桁にN進数の重みをかけて足せば良い

`101,101`の2進数を10進数に変換する場合、

2の2乗×1 + 2の1乗×0 + 2の0乗×1 . 2の-1乗×-1 + 2の-2乗×0 + 2の−3乗×1

`4 + 0 + 1 . 0.5 + 0 + 0.125 = 5.625` となる

## 10進数からN進数への基数変換
整数部は、Nで割って**下から**あまりを並べる

小数部は、Nをかけて**順に**整数部に並べる

## 2進数から8進数・16進数の関係
**2進数→8進数 小数点を基準に、3桁ずつ区切って、8進数に変換する**

`1100.01`の2進数を考える `001100.01`と補った上で、

`001(整数部の最初3桁)`は、2進数の重みを使うと`1`となる

`100(次の整数部3桁)`は、`4`となる

`010(小数部)`は、`2`となる

 結果として、`14.2`となる

**2進数→16進数 小数点を基準に、4桁ずつ区切って、16進数に変換する**

先程と同様だが、8進数と異なり、4桁区切り

`1100`は、2進数の重みをつかうと、`C`となる

`0100(小数部)`は、`4`となる

結果は、`C.4`になる

# 補数と固定小数点
## 補数
補数は、ある数を決められた数にするために、補う数

N進数には、N-1の補数とNの補数がある。

ある数にN-1の補数を補うと、与えられた桁数の最大値となる

ある数にNの補数を補うと、与えられた桁数の次の桁に桁上りする

### 2の補数の作り方
`0101`の補数をつくる

- 1の補数(N-1の補数): `1010` **ビットを反転するだけ**
- 対の負数(Nの補数): `1011` **1の補数に`+1`したもの**

## 固定小数点
コンピュータ内部における数値の表現として、固定小数点と浮動小数点がある

固定小数点は、小数点の位置を決められた場所に固定して表現する形式

# 浮動小数点
実数を扱う場合に使用する形式

## 浮動小数点の形式
110.01という数字を `1.1101 * 10**2`のように表す

**正規化**: 桁移動すること

# 誤差
真の値と表現する値との間に差が発生すること

## 誤差
### 桁あふれ誤差
演算結果がコンピュータの表現できる範囲を超えることで発生する誤差

- オーバーフロー: 表現できる範囲を超えること
- アンダーフロー: 浮動小数点で限りなく0に近づいて表現しきれなくなり、発生する

### 丸め誤差
切り捨て・切り上げ・四捨五入することで発生する誤差

### 桁落ち誤差
有効桁数が減少することで発生する誤差

絶対値がほぼ等しい数値の間で、同符号の減算や異符号の加算をしたときに発生する

0.556 - 0.554 = 0.002となる

これは、0.2 * 10**2となり、有効桁数が3桁から1桁に変わる

### 情報落ち誤差
小さな数値が計算結果に反映されないことで発生する誤差

絶対値の差が非常に大きい数値の間で加減算を行ったときに、絶対値の小さな数値が計算結果に反映されないことで発生する

100 + 0.00000000001 を足したときに、小さな数値は反映されない

### 打切り誤差
浮動小数点の計算処理の打切りすることで発生する誤差

# シフト演算
**Nビット左にシフト**: 2**n倍

**Nビットに右にシフト**: 1/2**n倍

左右にビットをずらして、乗算や除算の塩酸をすることを**シフト演算**とよぶ

## 論理シフト
符号を考慮しないシフト演算

- 溢れたビットは、捨てる
- 空いたビットは、0を入れる

`00011000`を左シフトすると `01100000`のように左のビットを削除して、右にビットを入れる

## 算術シフト
符号を考慮したシフト演算

### 算術左シフト
- 符号ビットはそのまま
- あふれたビットは捨てられる
- 空いたビットは0が入る

`11101000`をシフトすると`10100000`となる

### 算術右シフト
- 非業ビットはそのまま
- 溢れたビットは捨てられる
- 空いたビットには符号ビットと同じビットが入る

`11101000`をシフトすると`1111010`のようになる

### シフト演算と加算の組み合わせ

