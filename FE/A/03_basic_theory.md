# 基礎理論
# 基数変換
## 進数
人が日常的に使うのは、**10進数**

**N進数の重み**
小数点を基準に右へ、Nの0乗、1乗、2乗の順になっていく

小数点を基準に左へ、Nの-1乗、−2乗の順になっていく


## N進数から10進数への基数変換
各桁にN進数の重みをかけて足せば良い

`101,101`の2進数を10進数に変換する場合、

2の2乗×1 + 2の1乗×0 + 2の0乗×1 . 2の-1乗×-1 + 2の-2乗×0 + 2の−3乗×1

`4 + 0 + 1 . 0.5 + 0 + 0.125 = 5.625` となる

## 10進数からN進数への基数変換
整数部は、Nで割って**下から**あまりを並べる

小数部は、Nをかけて**順に**整数部に並べる

## 2進数から8進数・16進数の関係
**2進数→8進数 小数点を基準に、3桁ずつ区切って、8進数に変換する**

`1100.01`の2進数を考える `001100.01`と補った上で、

`001(整数部の最初3桁)`は、2進数の重みを使うと`1`となる

`100(次の整数部3桁)`は、`4`となる

`010(小数部)`は、`2`となる

 結果として、`14.2`となる

**2進数→16進数 小数点を基準に、4桁ずつ区切って、16進数に変換する**

先程と同様だが、8進数と異なり、4桁区切り

`1100`は、2進数の重みをつかうと、`C`となる

`0100(小数部)`は、`4`となる

結果は、`C.4`になる

# 補数と固定小数点
## 補数
補数は、ある数を決められた数にするために、補う数

N進数には、N-1の補数とNの補数がある。

ある数にN-1の補数を補うと、与えられた桁数の最大値となる

ある数にNの補数を補うと、与えられた桁数の次の桁に桁上りする

### 2の補数の作り方
`0101`の補数をつくる

- 1の補数(N-1の補数): `1010` **ビットを反転するだけ**
- 対の負数(Nの補数): `1011` **1の補数に`+1`したもの**

## 固定小数点
コンピュータ内部における数値の表現として、固定小数点と浮動小数点がある

固定小数点は、小数点の位置を決められた場所に固定して表現する形式

# 浮動小数点
実数を扱う場合に使用する形式

## 浮動小数点の形式
110.01という数字を `1.1101 * 10**2`のように表す

**正規化**: 桁移動すること

# 誤差
真の値と表現する値との間に差が発生すること

## 誤差
### 桁あふれ誤差
演算結果がコンピュータの表現できる範囲を超えることで発生する誤差

- オーバーフロー: 表現できる範囲を超えること
- アンダーフロー: 浮動小数点で限りなく0に近づいて表現しきれなくなり、発生する

### 丸め誤差
切り捨て・切り上げ・四捨五入することで発生する誤差

### 桁落ち誤差
有効桁数が減少することで発生する誤差

絶対値がほぼ等しい数値の間で、同符号の減算や異符号の加算をしたときに発生する

0.556 - 0.554 = 0.002となる

これは、0.2 * 10**2となり、有効桁数が3桁から1桁に変わる

### 情報落ち誤差
小さな数値が計算結果に反映されないことで発生する誤差

絶対値の差が非常に大きい数値の間で加減算を行ったときに、絶対値の小さな数値が計算結果に反映されないことで発生する

100 + 0.00000000001 を足したときに、小さな数値は反映されない

### 打切り誤差
浮動小数点の計算処理の打切りすることで発生する誤差

# シフト演算
**Nビット左にシフト**: 2**n倍

**Nビットに右にシフト**: 1/2**n倍

左右にビットをずらして、乗算や除算の塩酸をすることを**シフト演算**とよぶ

## 論理シフト
符号を考慮しないシフト演算

- 溢れたビットは、捨てる
- 空いたビットは、0を入れる

`00011000`を左シフトすると `01100000`のように左のビットを削除して、右にビットを入れる

## 算術シフト
符号を考慮したシフト演算

### 算術左シフト
- 符号ビットはそのまま
- あふれたビットは捨てられる
- 空いたビットは0が入る

`11101000`をシフトすると`10100000`となる

### 算術右シフト
- 非業ビットはそのまま
- 溢れたビットは捨てられる
- 空いたビットには符号ビットと同じビットが入る

`11101000`をシフトすると`1111010`のようになる

### シフト演算と加算の組み合わせ
2進数mの9倍を求めるときにはどうしたら良いか？

m * 9 = m * (2**3 + 1)

      = m * 2**3 + m という形になる

ようは、mを3ビット左にシフト移動したものにmを加えると9倍の数値を求められる

# 論理演算
## 論理演算
論理演算は、「1と0」、「真と偽」のようないずれか一方の値をもつデータ間で行われる演算

MIL記号で図式化したり、真理値表で表現したりする

- 論理和(OR): 入力(A,B)の少なくとも一方が1であれば、出力(A+B)は1となる演算 AまたはB
- 論理積(AND): 入力(A,B)の両方が1であれば、出力(A+B)が1となる演算 AかつB
- 否定(NOT): 入力(A)が0であれば、出力(A以外)は1。入力(A)が1であれば、出力(A以外)は0になる演算

## 論理演算の組合せ
- 排他的論理和(EOR,XOR): 入力(A,B)が異なれば、出力(A,B)が1  A・B以外 + A以外・Bの組合せで表せる。
- 否定論理和(NOR): 論理和と否定を組合せた演算 A以外+B以外の組合せ。AまたはBの否定で表せる
- 否定論理積(NAND): 倫理積と否定を組合せた演算 A・B以外の組合せ AかつBの否定で表せる

## ビット演算
元のビット列と特定のビット列でビット演算を行い、ビットを取り出したり、反転させたりできる

### ビット列の取り出し
特定のビットを取り出すには、取り出したいビットと1で論理積(AND)をとる

下位4ビットをとりだすには、

元のビット`00110001` に `00001111`を論理積(AND)とすることで、`00000001`を取り出せる

### ビットの反転
反転させるには、反転させたいビットと1で排他的論理和(EOR)をとる

下位4ビットを反転させるには、

元ビット`00110001`に `00001111`を論理和(EOR)とすることで、`00111110`のように反転させる

# 半加算器と全加算器
## 加算器
2進数の加算を行う回路

- 半加算器: 上位桁へ桁上がりのみ考慮した加算器 同桁の値(S)と桁上り(C)を出力する器
- 全加算器: 下位桁からの桁上りと上位桁への桁上りを考慮した加算器 上位桁への桁上り(C)だけでなく、下位桁(C`)も考慮した加算器

# 計測と制御
## アナログとデジタル
- アナログ: 連続的に変化する情報
- デジタル: 連続するアナログデータを細かく区切って、[0]と[1]に置き換えた不連続な情報

### A/D変換
アナログデータをデジタルデータに変換すること

デジタルデータなら、[0]と[1]を判別するだけで良い

**D/A変換**もある。  人はデジタル音楽を聞けないので、デジタルデータをアナログデータに変換する必要がある。

## PCM伝送方式
アナログの音声信号をデジタル符号に変換する方式

- 標本化: 時間的に連続したアナログ信号の波形を、一定の時間間隔で測定すること
  - サンプリングとも呼ぶ 1秒あたりのサンプリング回数を**サンプリング周波数(Hz)**と表す
- 量子化: 測定した信号を予め決められた感覚に対応した整数の近似値に変換すること
- 符号化: 量子化された値を2進数のデジタル符号に変換すること

## 制御技術
- フィードバック制御: 環境等の外部作用の影響をセンサで検知し、コンピュータが判断して修正動作を行う制御
- フィードフォワード制御: 前もって必要な修正動作を行う制御
- シーケンス制御: 予め定められた順序または条件に従って、制御の各段階を逐次勧めていく制御

**コンピュータ制御**
- A/Dコンバータ: アナログをデジタル変換する
- センサ: 物理量を検出して、電気信号に変える
  - ひずみゲージ: 絶縁体の表面に貼り付けた金属箔の電気抵抗の変化によって、物体の変形を検出
  - ジャイロセンサ: 端末の角速度や傾き、振動を検出
  - 人感センサ: 人体が発する赤外線等を探知
- アクチュエータ: コンピュータが出力した電気信号を回転運動・直線運動など力学的な運動に変える(シリンダ,モータなど)
- アンプ: マイクロフォンやセンサ等が出力した微小な電気信号を増幅する

### PWM
モータの回転速度やLEDの明るさ等をデジタル新語うで制御する方式

## クロック信号
電圧を縦、時間を横軸として、電圧の立上りと立下がりをみてタイミングをとっている

## 電力量
- A: 電流
- V: 電圧
- W: 電力(電気エネルギー)  W = A * V
- Wh: 電力量 電力を使った時間かけることで求められる Wh = W * h 

