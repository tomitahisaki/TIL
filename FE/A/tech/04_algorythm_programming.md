# アルゴリズムとプログラミング
# アルゴリズム
何らかの問題を有限の時間で解くための手順

## 変数
変数と呼ぶ、データを格納する領域を用いて、変数に値を格納する

- 例1: 数値[5]を、変数intAに代入する
- 例2: 文字列[基本情報]を、変数txtAに代入する
- 例3: 変数intAに1を加える intAは、6になる

## フローチャートと擬似言語
### フローチャート(流れ図)
記号を用いて、アルゴリズムを記述する方式

### アルゴリズムの制御構造
- 順次: Aの次にBを作成する
- 選択: もしCだったら、Dをする
- 繰返し: Eになるまで繰り返す

**構造化プログラミング**

プログラム全体を機能ごとに分割し、処理の制御構造としては、順次・選択・繰返しだけを用いることを原則とするプログラミングの手法

# 配列
データ構造は、データを効率よく管理するための形式

## 配列
要素番号を用いて、データを取得するデータ構造 同じ型の連続

- 要素: 配列中に格納された各データ
- 要素番号: 配列の各要素の添字
- 1次元配列: 要素番号を1からつけ、各要素にデータを格納する配列
- 2次元配列: 行と列で構成された表のイメージ

# データを記録するデータ部とデータ格納位置を示すポイント部で構成されるデータ構造
- 単方向リスト: 次のデータへのポインタを持っている
- 総方法リスト: 次のデータへのポインタと、前のデータのポインタを持っている
- 環状リスト: ポインタをたどり、データが環状に連結されている

### 配列とリストの違い

| 特徴 | 配列 | リスト |
| ---- | ---- | ------ |
| 格納領域 | 連続領域に順番通りに格納 | 非連続領域、非順番通りで可能 |
| 総データ数 | 先に決定(無駄な領域も発生) | 柔軟に変更可能 |
| データ挿入・削除 | 後ろのデータもずらす必要があり処理時間大きい | 前後のポインタのみ修正するので処理時間少ない |
| データアクセス | 要素番号で即アクセス可能 | ポインtあをたどるので遅い |


# キューとスタック
格納した順序でデータを取り出すことができるデータ構造

エンキュー: キューにデータを格納すること
デキュー: キューからデータを取り出すこと

キュー(FIFO構造): 先に格納したデータから先に取り出すデータ構造
スタック(LIFO構造): 後に格納したデータから先に取り出すデータ構造

プッシュ: スタックにデータを格納すること
ポップ: スタックからデータを取り出すこと

# 木構造
階層の上位から下位に接点をたどることによって、データを取り出すことができるデータ構造

節(ノード): 要素部分？
枝(ブランチ): 節と節をつなぐ部分
根(ルート): 最上位の節
葉(リーフ): 最下位の節

親: 上位の節
子: 下位の節

## 2分木の種類
- 完全2分木: 根から葉までの深さがすべて等しい2分木
- 2分探索木: 各節において、左の子<親<右の子　といった関係を持った2分木
- ヒープ木: 各節において、親<子 or 親>子 という関係を持った完全2分木
- 逆ポーランド記法: 数式の記述方法の1つで、演算子を被演算子の後に記述する表記法

# データの整列
ある規則に従って、データを並び替えること(ソート)
- 昇順: 小さなもの→大きなもの
- 降順: 大きなもの→小さなもの

## 整列法
- 基本交換法: 隣り合うデータを比較し、逆算であれば、交換していく整列法
  - 比較回数は、n(n-1)/2
- 基本選択法: データ列の最小値(最大値)を選択して交換、次にそれも除いた部分の中から最小値(最大値)を選択して交換していく整列法
  - 比較回数は、n(n-1)/2
- 基本挿入法: すでに整列済のデータ列の正しい位置に、データを挿入していく整列法
  - 比較回数は、n(n-1)/2 ただし、これ以下になる可能性もある

## その他の整列法
- シェルソート: ある一定期間おきに取り出した要素ないで基本挿入法を用いて整列させ、間隔を詰めながら、間隔が1になるまで繰返していく整列法
- クイックソート: 適当な基準値を決めて、基準より小さい値のグループと基準値より大きい値のグループにわける操作を繰り返していく整列法
- ヒープソート: 未整列な部分を順序木に構成し、その最大値を取り出す操作を繰り返していく整列法

# データの探索

