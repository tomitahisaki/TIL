# 正規表現2回目

# さまざまな区切り文字を許容

下記のような区切り文字が半角スペース、全角スペース、区切りなし、・区切りの場合は

どうやって、全てを選択するのか？

```ruby
ホテル あさくさ
ホテル　あさくさ
ホテル・あさくさ
ホテルあさくさ
ホテル・あざくさ
```

### 前回の[AB]をつかう

`[AB]` かっこの中の１文字を表す　メタ文字となるので、

[ 　・]という書き方で、半角スペースと全角スペースと・の１文字を表す　(全角スペースと半角スペースがあるので注意！)

```ruby
ホテル[ 　・]あさくさ
```

### 濁点を許容するには

あ**ざ**くさ、　あ**さ**くさ　のどちらも許容するには先程と同じ形を取れば良いので

```ruby
ホテル[ 　・]あ[さざ]くさ
```

### 区切りなしはどうするのか？

「～が1文字、または無し」を表現するためには `?` というメタ文字を使います。（文字量を指定するので **量指定子**）

```ruby
ホテル[ 　・]?あ[さざ]くさ
```

## 簡易的な区切り文字を表現するには

正規表現にはちょうど「任意の1文字」を表す `.` というメタ文字（文字クラス)

任意の１文字となるので、どんな１文字でも良くなる。　

```ruby
ホテル.?あ[さざ]くさ

# ホテル@あさくさ、ホテル%あさくさ　なども許容する
```

### JSでの書き方

```jsx
var text = "ホテル あさくさ\nホテル　あさくさ\nホテル・あさくさ\nホテルあさくさ\nホテル・あざくさ";

var lines = text.split(/\n/);

var targets = [];
for (var i = 0; i < lines.length; i++) {
  if (lines[i].match(/ホテル.?あ[さざ]くさ/)) {
    targets.push(lines[i]);
  }
}
targets;
```

## HTMLタグをCSVへ出力

```ruby
<select name="game_console">
<option value="wii_u">Wii U</option>
<option value="ps4">プレステ4</option>
<option value="gb">ゲームボーイ</option>
</select>
```

ここから、valueに入っている値のみを抽出したい

### valueの値に入っているパターンを考える

value= ダブルクオート、半角英数字かアンスコ、ダブルクオートのパターンになっている

直前の文字が1文字以上を表すのは `+` というメタ文字を使う(量指定子)

英数字かアンスコは　[a-z0-9_]で表す事ができます

```ruby
value = "[a-z0-9_]+"
```

これで、valueの値を指定することができる

### 表示テキストを抜き出す

テキストのみをどう抜き出すのか?

`>`で始まり、`<`で終わるという形で考える

さらに `.` と`+` で何かしらの文字が続くという意味になる

```ruby
>.+<
```

## 行全体にマッチする正規表現

今までのをもとにすると

```ruby
<option value="[a-z0-9_]+">.+<\/option>
# 正規表現を作るために/を使う必要があるので、\でエスケープするためにoption閉じタグ側に配置している
#　→正規表現では/abxc/のように作成するので、今回はエスケープするため設置
```

次に、valueと表示テキストをキャプチャする

valueと表示テキストを()で囲むことで可能

```ruby
<option value="([a-z0-9_]+)">(.+)<\/option>
```

キャプチャしたあと

```ruby
Match 1
1.	wii_u
2.	Wii U
Match 2
1.	ps4
2.	プレステ4
Match 3
1.	gb
2.	ゲームボーイ
```

### 表示テキストがない場合

```ruby
<select name="game_console">
<option value="none"></option>
<option value="wii_u">Wii U</option>
<option value="ps4">プレステ4</option>
<option value="gb">ゲームボーイ</option>
</select>
```

これだと今までの正規表現では value=”none”の行をカバーできない

表示テキストを抽出する正規表現

```ruby
.+  # これは任意の文字が１文字以上
↓
.*  #　これは直前の文字が０文字以上
```

こちらを使うと

```ruby
<option value="([a-z0-9_]+)">(.*)<\/option>
```

これで表示テキストがなくても抽出できる

### selectedになるoptionでも抽出するには

```ruby
<select name="game_console">
<option value="none"></option>
<option value="wii_u" selected>Wii U</option>
<option value="ps4">プレステ4</option>
<option value="gb">ゲームボーイ</option>
</select>
```

selectedがある行のみ、選択されていない

“selected”があるかないかという条件を追加することで、解決する

`A?` という表現は　Aが有りまたは、無しの意味なので　こちらを使って解決

→ただし、対象となる文字列をまとめて有りか無しかの判断にする必要があるので`()`　をつかって

グループ化する

```ruby
<option value="([a-z0-9_]+)"( selected)?>(.*)<\/option>
```

`( selected)?` が今回の正規表現　半角スペースに注意する

新しく追加した`( selected)?` もキャプチャされて、３つ目もできあがっているので

キャプチャされないようにしたい

```ruby
Match 1
1.  none
2.   
3.   
Match 2
1.  wii_u
2.  selected
3.  Wii U
Match 3
1.  ps4
2.   
3.  プレステ4
Match 4
1.  gb
2.   
3.  ゲームボーイ
```

キャプチャしないようにするには、`?:` を追加することで回避できる

```ruby
<option value="([a-z0-9_]+)"(?: selected)?>(.*)<\/option>
```

### メタ文字を省略に切り替える

`[0-9]`と`\d` は同じ意味(半角数字のみ)

`[a-z0-9A-Z]`と`\w`は同じ意味(半角英数字とアンスコとなる)

`\w` は　厳密に大文字のアルファベットも含むので少し異なる(今回は大文字を使っていない)

```ruby
[a-z0-9_]+　# 最初の段階

[a-z\d_]+ # 半角数字のみ変更

\w+       # 半角英数字とアンスコを含むに変更(厳密には大文字も含まれるので異なる）
```

置換した後

```ruby
<option value="(\w+)"(?: selected)?>(.*)<\/option>
```

## Rubyで置換する

下記の様に正規表現で表した部分を`gsub` でキャプチャ文字列を置換している

```ruby
html = <<-HTML
<select name="game_console">
<option value="none"></option>
<option value="wii_u" selected>Wii U</option>
<option value="ps4">プレステ4</option>
<option value="gb">ゲームボーイ</option>
</select>
HTML

replaced = html.gsub(/<option value="(\w+)"(?: selected)?>(.*)<\/option>/, **'\1,\2'**)

puts replaced
# <select name="game_console">
# none,
# wii_u,Wii U
# ps4,プレステ4
# gb,ゲームボーイ
# </select>
```

## ポイント　* と + の使い方

改行していないHTMLを正規表現で表すと、下記の様な表示テキストを取ってしまう

```ruby
<option value="ps4">プレステ4</option><option value="gb">ゲームボーイ</option>

#使う正規表現
<option value="(\w+)"(?: selected)?>(.*)<\/option>

#match group
1.  ps4
2.  プレステ4</option><option value="gb">ゲームボーイ
```

### 問題点

下記の部分

```ruby
>(.*)<
# >で始まり、任意の文字が0個以上連続し、(.*)、<で終わる　という意味
```

下記のような取り方をしている

```ruby
<option value="ps4">プレステ4</option><option value="gb">ゲームボーイ</option>
# >で始まり、<で終わる　意味を成している
```

### 解決策

### **任意の1文字という条件を変えてみる方法**

具体的には、 `<` 以外の任意文字となる

`[^<]` とすることで、`<` 以外の任意文字となる

`^` が否定の意味をもっているので、　`[^AB]` とすれば、AでもBでもない任意の1文字となる

```ruby
<option value="(\w+)"(?: selected)?>([^<]*)<\/option>
```

```ruby
<option value="ps4">プレステ4</option><option value="gb">ゲームボーイ</option>

#使う正規表現
<option value="(\w+)"(?: selected)?>(**[^<]***)<\/option>
# <以外の文字で表す文字を抽出することで、テキストのみを表せる。<を文字に含めていない

#match group
Match 1
1.	ps4
2.	プレステ4
Match 2
1.	gb
2.	ゲームボーイ
```

### **最短のマッチを返す指定する方法**

`*`や`+`をなくしてみる

`>(.*)<` の意味を厳密に書いてみる

　`>`ではじまり、任意の文字が0個以上連続し`(.*)` 、**最後**に見つかった`<` でおわる

これを厳密に書くと、

　`>`ではじまり、任意の文字が0個以上連続し`(.*)` 、 **最初**に見つかった`<` でおわる

となる

実現するには、`>(.*?)<` のようにつけてみる  `?` を`*?` や`+?` とすることで、最短のマッチ結果を返す(最小量指定子)

```ruby
<option value="ps4">プレステ4</option><option value="gb">ゲームボーイ</option>

#使う正規表現
<option value="(\w+)"(?: selected)?>(.*?)<\/option>
# 最初の<で終わる

#match group
Match 1
1.	ps4
2.	プレステ4
Match 2
1.	gb
2.	ゲームボーイ
```

## まとめ

- `?` は「直前の文字が1個、または無し」を表す
- `.` は「任意の1文字」を表す
- `+` は「直前の文字が1個以上」を表す
- `` は「直前の文字が0個以上」を表す
- `( )` はマッチする部分をキャプチャ（捕捉）する
- キャプチャした部分は置換するときに `$1` や `\1` で参照できる
- `\w` は「英単語を構成する文字（半角英数字とアンダースコア）」を表す
- `[^AB]` は「AでもなくBでもない任意の1文字」を表す
- 正規表現中の特別な文字は `\` でエスケープする
- `( )` はキャプチャだけでなく、グループ化にも使われる
- `(ABC)?` は「文字列 ABC があり、または無し」を表す
- `(?: )` はキャプチャ無しでグループ化する場合に使う
- `` と `+` は「貪欲」で最長マッチを返すため、使い方を誤ると思いがけない結果が返る
- `?` や `+?` にすると、最短マッチを返す